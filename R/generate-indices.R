#' Generate regional annual indices of abundance continent and strata and optionally for countries, states/provinces, or BCRs from analyses run on the stratifications that support these composite regions
#'
#' \code{generate_indices} creates a data frame of the annual indices
#'   of relative abundance by year. This data frame can then be used to
#'   plot population trajectories for the species, and to estimate trends.
#'
#' @param jags_mod JAGS list generated by \code{run_model}
#' @param jags_data data object used in \code{run_model}
#' @param quantiles vector of quantiles to be sampled from the posterior distribution Defaults to c(0.025,0.05,0.25,0.5,0.75,0.95,0.975)
#' @param regions vector selecting regional compilation(s) to calculate. Default is "continental","stratum", options also include "national", "prov_state", "bcr", and "bcr_by_country" for the stratifications that include areas that align with those regions.
#' @param alternate_n text string indicating the name of the alternative annual index parameter in a model, Default is "n", alternatives are "n2" which involves a different way of scaling the annual indices, "nsmooth" for the gam and gamye models which show only the smooth component of the trajectory, and "nslope" for the slope models which track only the linear slope component of the model
#' @param max_backcast an optional integer indicating the maximum number of years to backcast the stratum-level estimates before the first year in which the species was observed on any route in that stratum. 5 is used in the CWS national estimates. If the observed data in a given stratum do not include at least one non-zero observation of the species between the first year of the BBS and startyear+max_backcast, the stratum is flagged within the relevant regional summary. Default value, NULL ignores any backcasting limit (i.e., generates annual indices for the entire time series, regardless of when the species was first observed)
#' @param drop_exclude logical indicating if the strata that exceed the max_backcast threshold should be excluded from the calculations, Default is FALSE (regions are flagged and listed but not dropped)
#' @param startyear Optional first year for which to calculate the annual indices if a trajectory for only the more recent portion of the time series is desired. This is probably most relevant if max_backcast is set and so trajectories for different time-periods could include a different subset of strata (i.e., strata removed)
#' @param alt_region_names Optional dataframe indicating the strata to include in a custom spatial summary. Generate the basic dataframe structure with the \code{extract_strata_areas} function, then modify with an additional column indicating the strata to include in a custom spatial summary
#'
#' @return List of 6 objects
#'   \item{data_summary}{dataframe with the following columns}
#'   \item{Year}{Year of particular index}
#'   \item{Region}{Region name}
#'   \item{Region_alt}{Long name for region}
#'   \item{Region_type}{Type of region including continental, national,Province_State,BCR, bcr_by_country, or stratum}
#'   \item{Strata_included}{Strata included in the annual index calculations}
#'   \item{Strata_excluded}{Strata potentially excluded from the annual index calculations because they have no observations of the species in the first part of the time series, see arguments max_backcast and startyear}
#'   \item{Index}{Strata-weighted count index}
#'   \item{additional columns for each of the values in quantiles}{quantiles of the posterior distribution}
#'   \item{obs_mean}{Mean of the observed annual counts of birds across all routes and all years. An alternative estimate of the average relative abundance of the species in the region and year. Differences between this and the annual indices are a function of the model. For composite regions (i.e., anything other than stratum-level estimates) this average count is calculated as an area-weighted average across all strata included}
#'   \item{nrts}{Number of BBS routes that contributed data for this species, region, and year}
#'   \item{nrts_total}{Number of BBS routes that contributed data for this species and region for all years in the selected time-series, i.e., all years since \code{startyear}}
#'   \item{nnzero}{Number of BBS routes on which this species was observed (i.e., count is > 0) in this region and year}
#'   \item{backcast_flag}{approximate annual average proportion of the covered species range that is free of extrapolated population trajectories. e.g., 1.0 = data cover full time-series, 0.75 = data cover 75 percent of time-series. Only calculated if max_backcast != NULL}
#'
#'   \item{samples}{array of all posterior draws}
#'   \item{area-weights}{data frame of the strata names and area weights used to calculate the continental estimates}
#'   \item{y_min}{first year used in the summary, scale 1:length of time-series}
#'   \item{y_max}{last year used in the summary, scale 1:length of time-series}
#'   \item{startyear}{first year used in the summary, scale 1966:2018}
#'
#'
#' @examples
#'
#' # Toy example with Pacific Wren sample data
#' # First, stratify the sample data
#'
#' strat_data <- stratify(by = "bbs_cws", sample_data = TRUE)
#'
#' # Prepare the stratified data for use in a JAGS model.
#' jags_data <- prepare_jags_data(strat_data = strat_data,
#'                                species_to_run = "Pacific Wren",
#'                                model = "firstdiff",
#'                                min_year = 2009,
#'                                max_year = 2018)
#'
#' # Now run a JAGS model.
#' jags_mod <- run_model(jags_data = jags_data,
#'                       n_adapt = 0,
#'                       n_burnin = 0,
#'                       n_iter = 10,
#'                       n_thin = 1)
#'
#' # Generate the continental and stratum indices
#' indices <- generate_indices(jags_mod = jags_mod,
#'                             jags_data = jags_data)
#'
#' # Generate only national indices
#' indices_nat <- generate_indices(jags_mod = jags_mod,
#'                                 jags_data = jags_data,
#'                                 regions = c("national"))
#'
#' @noRd

generate_indices_orig <- function(jags_mod = NULL,
                             jags_data = NULL,
                             quantiles = c(0.025,0.05,0.25,0.75,0.95,0.975),
                             regions = c("stratum","continental"),
                             alternate_n = "n",
                             startyear = NULL,
                             drop_exclude = FALSE,
                             max_backcast = NULL,
                             alt_region_names = NULL)
{
  if (is.null(jags_mod))
  {
    stop("No model output supplied to generate_indices()."); return(NULL)
  }

  if (is.null(jags_data))
  {
    warning("No original data object supplied to generate_indices(). Number of routes will not be calculated")
  }

  if(!is.null(jags_data)){
    data_list <- extract_index_data_orig(jags_mod = jags_mod,alt_n = alternate_n,jags_data = jags_data)
  }else{
    data_list <- extract_index_data_orig(jags_mod = jags_mod,alt_n = alternate_n)

  }
  n <- data_list$n
  stratify_by <- jags_mod$stratify_by
  original_data = data_list$original_data

  if(stratify_by %in% c("bcr", "latlong") & ( "national" %in% regions | "prov_state" %in% regions)){
    stop("Stratification of model does not match desired regions. BCRs and latlong degree blocks can not be divided by political boundaries"); return(NULL)
  }
  if(stratify_by == c("state") & c("bcr") %in% regions){
    stop("Stratification of model does not match desired regions. States and Provinces can not be divided by BCRs"); return(NULL)
  }

  area_weights <- data_list$area_weights
  area_weights$region = as.character(area_weights$region)


  if(!is.null(startyear)){
    inity = min(data_list$r_year)-1
    y_min <- startyear-inity
    y_max <- data_list$y_max
    mr_year <- startyear

    if(inity > startyear){
      y_min <- data_list$y_min
      y_max <- data_list$y_max
      mr_year <- min(data_list$r_year)
    }

  }else{
    y_min <- data_list$y_min
    y_max <- data_list$y_max
    mr_year <- min(data_list$r_year)
  }


  if(is.null(max_backcast)){
    max_backcast <- length(y_min:y_max)
  }

  bugs_data = data_list$bugs_data

  rawall = data.frame(year = bugs_data$year,
                      count = bugs_data$count,
                      strat = bugs_data$strat)
  rawnonz = rawall[which(rawall$count > 0),]

  fyearbystrat = tapply(rawnonz$year,rawnonz[,c("strat")],min,na.rm = TRUE)

  raw = rawall[which(rawall$year >= y_min),]

  original_data <- original_data[which(original_data$Year_Factored >= y_min),]
  nrts_total_by_strat <- tapply(original_data$Route,original_data$Stratum_Factored,FUN = function(x){length(unique(x))})
  non_zero_weight = bugs_data$nonzeroweight

  n_samples <- dim(n)[1]

  if(is.null(alt_region_names)){
    region_names <- utils::read.csv(system.file("composite-regions", strata[[stratify_by]], package = "bbsBayes"),stringsAsFactors = FALSE)
  }else{
    region_names_o <- utils::read.csv(system.file("composite-regions", strata[[stratify_by]], package = "bbsBayes"),stringsAsFactors = FALSE)

    region_names <- alt_region_names
    if(nrow(region_names) != nrow(region_names_o)){
      stop("Alt_region_names does not match the original model stratification. Please ensure your alternative regions exactly match the model stratification"); return(NULL)
    }
    if(all(regions[-which(regions %in% c("continental","stratum"))] %in% names(region_names)) == FALSE){
      stop("desired regions do not match the columns in your alternative regions dataframe"); return(NULL)

    }
  }

  region_names$stratum = region_names$region
  region_names$continental = "Continental"


  data_summary <- data.frame(Year = integer(),
                             Region = character(),
                             Region_alt = character(),
                             Region_type = character(),
                             Strata_included = character(),
                             Strata_excluded = character(),
                             Index = double(),
                             stringsAsFactors = FALSE)
  for(qq in quantiles){
    data_summary[,paste0("Index_q_",qq)] <- double()
  }


  data_summary$obs_mean <- double()
  data_summary$nrts <- integer()
  data_summary$nnzero <- integer()
  data_summary$nrts_total <- integer()

  N_all <- list()
  n_index <- 0
  for(rr in regions){ #selecting the type of composite region

    rrall = unique(region_names[,rr]) #list of composite regions of type rr
    col_region_name <- rr
    if(rr == "national"){col_region_name <- "Country"}
    if(rr == "prov_state"){col_region_name <- "Province_State"}
    # if(rr == "bcr"){col_region_name <- rr}
    # if(rr == "bcr_by_country"){col_region_name <- rr}
    # if(rr == "stratum"){col_region_name <- rr}
    # if(rr == "continental"){col_region_name <- rr}

    for(rrs in rrall){ # for each of the composite regions

      region_alt_name <- as.character(unique(region_names[which(region_names[,rr] == rrs),col_region_name]))
      if(rr == "bcr"){region_alt_name = paste("BCR",region_alt_name,sep = "_")}

      st_sela <- as.character(region_names[which(region_names[,rr] == rrs),"region"])

      st_rem <- NULL
      strata_sel <- area_weights[which(area_weights$region %in% st_sela),"num"]
      st_sel <- area_weights[which(area_weights$region %in% st_sela),"region"]
      pz_area <- area_weights[,"area_sq_km"]*non_zero_weight
      #pz_area is the non_zero_weighted area (the area of the stratum * proportion of the routes included)
      # it's designed to estimate the proportional contribution (excluding abundance) of that region to the composite trajectory

      if(length(strata_sel)<1){next}


      obs_df = data.frame(year = integer(),
                          strat = integer(),
                          obs_mean = double(),
                          nrts = integer(),
                          nnzero = integer(),
                          nrts_total = integer(),
                          strata_rem_flag = double())
      for (j in strata_sel)
      {
        rawst <- raw[which(raw$strat == j),c("year","count")]
        yrs <- data.frame(year = c(y_min:y_max))
        rawst <- merge(rawst,yrs,by = "year",all = TRUE)
        rawst <- rawst[order(rawst$year),]

        o_mns <- as.numeric(by(rawst[,2],INDICES = rawst[,1],FUN = mean,na.rm = TRUE))
        nrts <- as.numeric(by(rawst[,2],INDICES = rawst[,1],FUN = function(x){length(which(!is.na(x)))}))
        nnzero <- as.numeric(by(rawst[,2],INDICES = rawst[,1],FUN = function(x){length(which(x>0))}))
        strata_p <- pz_area[j]/sum(pz_area[strata_sel])

        if(sum(nnzero[1:max_backcast]) < 1 & as.integer(fyearbystrat[j]) > y_min){ #if no observations of the species in the first 5 years, then remove the strata from trend summaries
          st_rem <- c(st_rem,as.character(area_weights[which(area_weights$num == j),"region"]))
          strem_flag <- c(rep(strata_p,fyearbystrat[j]-(y_min-1)),rep(0,y_max-fyearbystrat[j]))
          #if(length(strata_sel) == 1){break}
        }else{
          strem_flag <- rep(0,length(y_max:y_min))

        }


        obs_df_t <- data.frame(year = c(y_min:y_max),
                               strat = j,
                               obs_mean = o_mns*((area_weights$area_sq_km[which(area_weights$num == j)])/ sum(area_weights[which(area_weights$num %in% strata_sel),"area_sq_km"]))*(non_zero_weight[j]),
                               nrts = nrts,
                               nnzero = nnzero,
                               nrts_total = as.integer(nrts_total_by_strat[j]),
                               strata_rem_flag = strem_flag)

        obs_df <- rbind(obs_df,obs_df_t)
      }


      if(!is.null(st_rem)){
        if(drop_exclude){
          strata_sel <- strata_sel[-which(strata_sel %in% area_weights[which(area_weights$region %in% st_rem),"num"])]
          st_sel <- st_sel[-which(st_sel %in% st_rem)]
        }
      }

      if(length(strata_sel)<1){next}

      #n_weight <- n[,,y_min:y_max]
      #



      n_weight <- array(NA,dim = c(dim(n)[c(1,2)],length(y_min:y_max)))
      n_weight[,,1:length(y_min:y_max)] <- n[,,y_min:y_max]


      # Weight each sampled n
      for (i in 1:n_samples)
      {
        for (j in strata_sel)
        {
          n_weight[i,j,] <- (n_weight[i,j,] * area_weights$area_sq_km[which(area_weights$num == j)])/ sum(area_weights[which(area_weights$num %in% strata_sel),"area_sq_km"])
        }
      }
      n_weight <- n_weight[,strata_sel,]

      if(length(strata_sel) > 1){
        N <- apply(n_weight, c(1,3),sum)
      }else{
        N <- n_weight
      }
      n_index <- n_index+1
      N_all[[n_index]] <- N
      names(N_all)[n_index] <- paste(rr,rrs,sep = "_")

      n_median <- apply(N, 2, median)
      data_summaryr <- data.frame(Year = seq(y_min:y_max),
                                  Region = rrs,
                                  Region_alt = region_alt_name,
                                  Region_type = rr,
                                  Strata_included = paste(st_sel,collapse = " ; "),
                                  Strata_excluded = paste(st_rem,collapse = " ; "),
                                  Index = n_median,
                                  stringsAsFactors = FALSE)
      for(qq in quantiles){
        data_summaryr[,paste0("Index_q_",qq)] <- apply(N,2,stats::quantile,probs = qq)
      }

      data_summaryr$Year <- as.integer((data_summaryr$Year - 1) + mr_year)
      data_summaryr$obs_mean <- as.numeric(by(obs_df[,3],INDICES = obs_df[,1],FUN = sum,na.rm = TRUE))
      data_summaryr$nrts <- as.numeric(by(obs_df[,4],INDICES = obs_df[,1],FUN = sum,na.rm = TRUE))
      data_summaryr$nnzero <- as.numeric(by(obs_df[,5],INDICES = obs_df[,1],FUN = sum,na.rm = TRUE))
      data_summaryr$nrts_total <- as.numeric(by(obs_df[,6],INDICES = obs_df[,1],FUN = sum,na.rm = TRUE))
      data_summaryr$backcast_flag <- 1-as.numeric(by(obs_df[,7],INDICES = obs_df[,1],FUN = sum,na.rm = TRUE))

      data_summary = rbind(data_summary,data_summaryr)


    }
  }


  return(list(data_summary = data_summary,
              samples = N_all,
              area_weights = area_weights,
              y_min = y_min,
              y_max = y_max,
              startyear = mr_year,
              regions = regions,
              raw_data = raw))
}


#' Generate regional annual indices of abundance continent and strata and optionally for countries, states/provinces, or BCRs from analyses run on the stratifications that support these composite regions (TIDY)
#'
#' \code{generate_indices} creates a data frame of the annual indices
#'   of relative abundance by year. This data frame can then be used to
#'   plot population trajectories for the species, and to estimate trends.
#'
#' @param jags_mod JAGS list generated by \code{run_model}
#' @param jags_data data object used in \code{run_model}
#' @param quantiles vector of quantiles to be sampled from the posterior distribution Defaults to c(0.025,0.05,0.25,0.5,0.75,0.95,0.975)
#' @param regions vector selecting regional compilation(s) to calculate. Default is "continental","stratum", options also include "national", "prov_state", "bcr", and "bcr_by_country" for the stratifications that include areas that align with those regions.
#' @param alternate_n text string indicating the name of the alternative annual index parameter in a model, Default is "n", alternatives are "n2" which involves a different way of scaling the annual indices, "nsmooth" for the gam and gamye models which show only the smooth component of the trajectory, and "nslope" for the slope models which track only the linear slope component of the model
#' @param max_backcast an optional integer indicating the maximum number of years to backcast the stratum-level estimates before the first year in which the species was observed on any route in that stratum. 5 is used in the CWS national estimates. If the observed data in a given stratum do not include at least one non-zero observation of the species between the first year of the BBS and start_year+max_backcast, the stratum is flagged within the relevant regional summary. Default value, NULL ignores any backcasting limit (i.e., generates annual indices for the entire time series, regardless of when the species was first observed)
#' @param drop_exclude logical indicating if the strata that exceed the max_backcast threshold should be excluded from the calculations, Default is FALSE (regions are flagged and listed but not dropped)
#' @param start_year Optional first year for which to calculate the annual indices if a trajectory for only the more recent portion of the time series is desired. This is probably most relevant if max_backcast is set and so trajectories for different time-periods could include a different subset of strata (i.e., strata removed)
#' @param alt_region_names Optional dataframe indicating the strata to include in a custom spatial summary. Generate the basic dataframe structure with the \code{extract_strata_areas} function, then modify with an additional column indicating the strata to include in a custom spatial summary
#'
#' @return List of 6 objects
#'   \item{data_summary}{dataframe with the following columns}
#'   \item{Year}{Year of particular index}
#'   \item{Region}{Region name}
#'   \item{Region_alt}{Long name for region}
#'   \item{Region_type}{Type of region including continental, national,Province_State,BCR, bcr_by_country, or stratum}
#'   \item{Strata_included}{Strata included in the annual index calculations}
#'   \item{Strata_excluded}{Strata potentially excluded from the annual index calculations because they have no observations of the species in the first part of the time series, see arguments max_backcast and start_year}
#'   \item{Index}{Strata-weighted count index}
#'   \item{additional columns for each of the values in quantiles}{quantiles of the posterior distribution}
#'   \item{obs_mean}{Mean of the observed annual counts of birds across all routes and all years. An alternative estimate of the average relative abundance of the species in the region and year. Differences between this and the annual indices are a function of the model. For composite regions (i.e., anything other than stratum-level estimates) this average count is calculated as an area-weighted average across all strata included}
#'   \item{nrts}{Number of BBS routes that contributed data for this species, region, and year}
#'   \item{nrts_total}{Number of BBS routes that contributed data for this species and region for all years in the selected time-series, i.e., all years since \code{start_year}}
#'   \item{nnzero}{Number of BBS routes on which this species was observed (i.e., count is > 0) in this region and year}
#'   \item{backcast_flag}{approximate annual average proportion of the covered species range that is free of extrapolated population trajectories. e.g., 1.0 = data cover full time-series, 0.75 = data cover 75 percent of time-series. Only calculated if max_backcast != NULL}
#'
#'   \item{samples}{array of all posterior draws}
#'   \item{area-weights}{data frame of the strata names and area weights used to calculate the continental estimates}
#'   \item{y_min}{first year used in the summary, scale 1:length of time-series}
#'   \item{y_max}{last year used in the summary, scale 1:length of time-series}
#'   \item{start_year}{first year used in the summary, scale 1966:2018}
#'
#'
#' @examples
#'
#' # Toy example with Pacific Wren sample data
#' # First, stratify the sample data
#'
#' strat_data <- stratify(by = "bbs_cws", sample_data = TRUE)
#'
#' # Prepare the stratified data for use in a JAGS model.
#' jags_data <- prepare_jags_data(strat_data = strat_data,
#'                                species_to_run = "Pacific Wren",
#'                                model = "firstdiff",
#'                                min_year = 2009,
#'                                max_year = 2018)
#'
#' # Now run a JAGS model.
#' jags_mod <- run_model(jags_data = jags_data,
#'                       n_adapt = 0,
#'                       n_burnin = 0,
#'                       n_iter = 10,
#'                       n_thin = 1)
#'
#' # Generate the continental and stratum indices
#' indices <- generate_indices(jags_mod = jags_mod,
#'                             jags_data = jags_data)
#'
#' # Generate only national indices
#' indices_nat <- generate_indices(jags_mod = jags_mod,
#'                                 jags_data = jags_data,
#'                                 regions = c("national"))
#'
#' @noRd

generate_indices_tidy <- function(jags_mod = NULL,
                                  jags_data = NULL,
                                  quantiles = c(0.025,0.05,0.25,0.75,0.95,0.975),
                                  regions = c("stratum","continental"),
                                  alternate_n = "n",
                                  start_year = NULL,
                                  drop_exclude = FALSE,
                                  max_backcast = NULL,
                                  alt_region_names = NULL)
{
  if (is.null(jags_mod))
  {
    stop("No model output supplied to generate_indices()."); return(NULL)
  }

  if (is.null(jags_data))
  {
    warning("No original data object supplied to generate_indices(). Number of routes will not be calculated")
  }

  if(!is.null(jags_data)){
    data_list <- extract_index_data_tidy(jags_mod = jags_mod,alt_n = alternate_n,jags_data = jags_data)
  }else{
    data_list <- extract_index_data_tidy(jags_mod = jags_mod,alt_n = alternate_n)

  }

  n <- data_list$n

  stratify_by <- jags_mod$stratify_by
  #original_data = data_list$original_data

  if(stratify_by %in% c("bcr", "latlong") & ( "national" %in% regions | "prov_state" %in% regions)){
    stop("Stratification of model does not match desired regions. BCRs and latlong degree blocks can not be divided by political boundaries"); return(NULL)
  }
  if(stratify_by == c("state") & c("bcr") %in% regions){
    stop("Stratification of model does not match desired regions. States and Provinces can not be divided by BCRs"); return(NULL)
  }

  area_weights <- data_list$area_weights
  area_weights$region = as.character(area_weights$region)


  if(!is.null(start_year)){
    inity = min(data_list$r_year)-1
    #y_min <- start_year-inity
    #y_max <- data_list$y_max
    #mr_year <- start_year
    n_years <- max(jags_data$year)

    if(inity > start_year){
      #y_min <- data_list$y_min
      #y_max <- data_list$y_max
      #mr_year <- min(data_list$r_year)
      warning(
        "Value of ", start_year, " for `start_year` is earlier than the ",
        "earliest year of the data, using ", start_year <- min(jags_data$r_year),
        " instead", call. = FALSE)
      n_years <- max(jags_data$year)
    }

  }else{
    n_years <- max(jags_data$year)
    start_year <- min(jags_data$r_year)
    #y_min <- data_list$y_min
    #y_max <- data_list$y_max
    #mr_year <- min(data_list$r_year)
  }


  if(is.null(max_backcast)){
    max_backcast <- n_years
  }

  # Use jags_data
  #rawall = data.frame(year = bugs_data$year,
  #                     count = bugs_data$count,
  #                     strat = bugs_data$strat)
  # raw <- as.data.frame(jags_data[c("year", "count", "strat")])
  # rawnonz <- raw[raw$count > 0, ]

  jags_df <- as.data.frame(jags_data[c("year", "count", "strat", "strat_name",
                                       "obser", "firstyr", "route", "r_year",
                                       "month", "day")])

  #fyearbystrat = tapply(rawnonz$year,rawnonz[,c("strat")],min,na.rm = TRUE)

  # fyearbystrat <- rawnonz %>%
  #   dplyr::group_by(strat) %>%
  #   dplyr::summarize(min_year = min(year, na.rm = TRUE)) %>%
  #   dplyr::pull(min_year)

  #raw = rawall[rawall$year >= y_min,]

  #original_data <- original_data[which(original_data$Year_Factored >= y_min),]
  # nrts_total_by_strat <- tapply(jags_data$route, jags_data$strat,
  #                              FUN = function(x){length(unique(x))})
  # nrts_total_by_strat <- as.data.frame(jags_data[c("route", "strat")]) %>%
  #   dplyr::group_by(strat) %>%
  #   dplyr::summarize(n_routes = dplyr::n_distinct(route)) %>%
  #   dplyr::pull(n_routes)
  #
  # non_zero_weight <- jags_data$nonzeroweight


  strat_meta <- as.data.frame(jags_data[c("strat", "year", "count", "route")]) %>%
    dplyr::group_by(strat) %>%
    dplyr::summarize(start_year = min(year[count > 0], na.rm = TRUE),
                     nrts_total = dplyr::n_distinct(route)) %>%
    dplyr::mutate(non_zero_weight  = jags_data$nonzeroweight) %>%
    dplyr::left_join(area_weights, by = c("strat" = "num"))


  n_samples <- dim(n)[1]

  # Clarify regions
  if(!is.null(alt_region_names)) {
    if(nrow(region_names) != nrow(alt_region_names)){
      stop(
        "Alt_region_names does not match the original model stratification. ",
        "Please ensure your alternative regions exactly match the model ",
        "stratification", call. = FALSE)
    }
    region_names <- alt_region_names
    if(all(regions[-which(regions %in% c("continental","stratum"))] %in%
           names(region_names)) == FALSE){
      stop("desired regions do not match the columns in your alternative ",
           "regions dataframe", call. = FALSE)
    }
  }

  region_names <- utils::read.csv(system.file("composite-regions",
                                              strata[[stratify_by]],
                                              package = "bbsBayes"),
                                  stringsAsFactors = FALSE) %>%
    dplyr::mutate(stratum = region, continental = "Continental")


  n_index <- 0

  # Calculate strata/year-level observation statistics
  obs_strat <- jags_df %>%
    dplyr::select(strat, year, count) %>%
    dplyr::group_by(strat) %>%
    tidyr::complete(year = 1:n_years) %>%
    dplyr::arrange(strat, year, count) %>%
    dplyr::group_by(strat, year) %>%
    dplyr::summarize(o_mns = mean(count, na.rm = TRUE),
                     nrts = sum(!is.na(count)),
                     nnzero = sum(count > 0, na.rm = TRUE),
                     strem_flag = 0, .groups = "drop")


  data_summary <- dplyr::tibble()
  N_all <- list()


  for(rr in regions) { #selecting the type of composite region

    # Calculate strata-level information for sub-regions in this composite region
    strat_meta_sub <- region_names %>%
      dplyr::select("region", .data[[rr]]) %>%
      dplyr::inner_join(strat_meta, ., by = "region") %>%
      dplyr::group_by(.data[[rr]]) %>%
      dplyr::mutate(pz_area = area_sq_km * non_zero_weight,
                    strata_p = pz_area / sum(pz_area),
                    area_weight = area_sq_km / sum(area_sq_km),
                    area_weight_non_zero = area_weight * non_zero_weight) %>%
      dplyr::ungroup()

    # Calculate sample statistics for this composite region
    samples <- strat_meta_sub %>%
      tidyr::nest(data = -.data[[rr]]) %>%
      dplyr::group_by(.data[[rr]]) %>%
      dplyr::summarize(N = purrr::map(.data$data, calc_weights,
                                      n = .env$n, n_years = .env$n_years,
                                      n_samples = .env$n_samples),
                       N_names = paste0(rr, "_", .data[[rr]]),
                       Q = purrr::map(.data$N, calc_quantiles,
                                      .env$quantiles)) %>%
      dplyr::mutate(r = .env$rr)

    # Save sample stats for output
    N_all <- append(N_all, setNames(samples$N, samples$N_names))

    # Calculate observation statistics for this composite region
    obs_region <- obs_strat %>%
      dplyr::inner_join(strat_meta_sub, by = "strat") %>%
      dplyr::mutate(obs_mean = o_mns * area_weight_non_zero) %>%
      dplyr::group_by(.data[[rr]], strat) %>%
      dplyr::mutate(
        flag_remove = sum(nnzero[1:max_backcast]) < 1 & start_year > 1,
        flag_year = dplyr::if_else(flag_remove & year <= start_year, strata_p, 0)) %>%
      dplyr::group_by(.data[[rr]], year) %>%
      dplyr::summarize(
        dplyr::across(.cols = c(obs_mean, nrts, nnzero, nrts_total, flag_year),
                      sum, na.rm = TRUE),
        flag_remove = unique(flag_remove),
        Strata_included = paste0(region[!flag_remove], collapse = " ; "),
        Strata_excluded = paste0(region[flag_remove], collapse = " ; "),
        .groups = "drop")

    # Calculate data summaries for output
    data_summary <- obs_region %>%
      dplyr::left_join(calc_alt_names(rr, region_names), by = rr) %>%
      dplyr::left_join(tidyr::unnest(samples, "Q"), by = c(rr, "year")) %>%
      dplyr::mutate(backcast_flag = 1 - flag_year,
                    Year = .env$start_year + year - 1,
                    Region_type = .env$rr) %>%
      dplyr::rename(Region = .data[[rr]]) %>%
      dplyr::select("Year", "Region", "Region_alt", "Region_type",
                    "Strata_included", "Strata_excluded",
                    "Index", dplyr::contains("Index_q"),
                    "obs_mean", "nrts", "nnzero", "nrts_total", "backcast_flag") %>%
      dplyr::bind_rows(data_summary, .)
  }

  list(data_summary = data_summary,
       samples = N_all,
       area_weights = area_weights,
       y_min = 1,
       y_max = n_years,
       start_year = start_year,
       regions = regions,
       raw_data = jags_df)
}


#' Regional annual indices of abundance
#'
#' Calculate annual indices of relative abundance by year for different regions.
#' These indices can then be used to plot population trajectories for the
#' species, and to estimate trends.
#'
#' @param quantiles Numeric. Vector of quantiles to be sampled from the
#'   posterior distribution. Default is
#'   `c(0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975)`. Note that these quantiles
#'   will be used to create confidence interval bands in `plot_indices()` and
#'   by quantiles in `generate_trends()`, so make sure you specify the ones you
#'   want to use later in this step.
#' @param regions Character. Which region(s) to summarize and calculate indices
#'   for. Default is "continent" and "stratum". Options also include "country",
#'   "prov_state", "bcr", and "bcr_by_country". Note that some regions only
#'   apply to specific stratifications. You can also supply a custom region that
#'   exists as a column in the `regions_index` data frame (see
#'   examples for more details).
#' @param regions_index Data frame. Custom regions to summarize. Data frame must
#'   include all strata in the original data in one column (`strata_name`), and
#'   any custom regions defined as categories in other columns.
#' @param alternate_n Character. Indicating the name of the alternative annual
#'   index parameter in a model, Default is "n", alternatives are "n2" which
#'   involves a different way of scaling the annual indices, "n_smooth" for the
#'   gam and gamye models which show only the smooth component of the
#'   trajectory, and "n_slope" for the slope models which track only the linear
#'   slope component of the model.
#' @param max_backcast Numeric. The number of years to back cast stratum-level
#'   estimates before the first year that species was observed on any route in
#'   that stratum. Default is `NULL`, which generates annual indices for the
#'   entire time series and ignores back-casting. CWS national estimates use a
#'   back cast of 5. Note that unless `drop_exclude = TRUE`, problematic years
#'   are only flagged, not omitted. See Details for more specifics.
#' @param drop_exclude Logical. Whether or not strata that exceed the
#'   `max_backcast` threshold should be excluded from the calculations. Default
#'   is `FALSE` (regions are flagged and listed but not dropped).
#' @param start_year Numeric. Trim the data record before calculating annual
#'   indices.
#' @param jags_mod Defunct. Use `model_output` instead
#' @param jags_data Defunct.
#' @param alt_region_names Defunct. Use `regions_index` instead
#' @param startyear Deprecated. Use `start_year` instead
#'
#' @inheritParams common_docs
#'
#' @details
#'   `max_backcast` is a way to deal with the fact that the species of interest
#'   may not appear in the data until several years after the start of the record.
#'   `max_backcast` specifies how many years can occur before the stratum is flagged.
#'   A `max_backcast` of 5 will flag any stratum without a non-zero (or non-NA)
#'   observation within the first 5 years of the data record. Note that records
#'   are *only* flagged unless `drop_exclude = TRUE`.
#'   If you find that the early data record is sparse and results in the
#'   exclusion of many strata, consider trimming the early years by specifying a
#'   `start_year`.
#'
#'
#' @return List of 6 objects
#'   \item{data_summary}{dataframe with the following columns}
#'   \item{Year}{Year of particular index}
#'   \item{Region}{Region name}
#'   \item{Region_alt}{Long name for region}
#'   \item{Region_type}{Type of region including continental, national,Province_State,BCR, bcr_by_country, or stratum}
#'   \item{Strata_included}{Strata included in the annual index calculations}
#'   \item{Strata_excluded}{Strata potentially excluded from the annual index calculations because they have no observations of the species in the first part of the time series, see arguments max_backcast and start_year}
#'   \item{Index}{Strata-weighted count index}
#'   \item{additional columns for each of the values in quantiles}{quantiles of the posterior distribution}
#'   \item{obs_mean}{Mean of the observed annual counts of birds across all routes and all years. An alternative estimate of the average relative abundance of the species in the region and year. Differences between this and the annual indices are a function of the model. For composite regions (i.e., anything other than stratum-level estimates) this average count is calculated as an area-weighted average across all strata included}
#'   \item{nrts}{Number of BBS routes that contributed data for this species, region, and year}
#'   \item{nrts_total}{Number of BBS routes that contributed data for this species and region for all years in the selected time-series, i.e., all years since \code{start_year}}
#'   \item{nnzero}{Number of BBS routes on which this species was observed (i.e., count is > 0) in this region and year}
#'   \item{backcast_flag}{approximate annual average proportion of the covered species range that is free of extrapolated population trajectories. e.g., 1.0 = data cover full time-series, 0.75 = data cover 75 percent of time-series. Only calculated if max_backcast != NULL}
#'
#'   \item{samples}{array of all posterior draws}
#'   \item{area-weights}{data frame of the strata names and area weights used to calculate the continental estimates}
#'   \item{y_min}{first year used in the summary, scale 1:length of time-series}
#'   \item{y_max}{last year used in the summary, scale 1:length of time-series}
#'   \item{start_year}{first year used in the summary, scale 1966:2018}
#'
#' @examples
#'
#' # Toy example with Pacific Wren sample data
#' # First, stratify the sample data
#' s <- stratify(by = "bbs_cws", sample_data = TRUE)
#'
#' # Prepare the stratified data for use in modelling
#' d <- prepare_data(s,
#'                   min_year = 2009,
#'                   max_year = 2018)
#'
#' # Now run the model (fast but not good, just for illustration)
#' m <- run_model(d, model = "first_diff",
#'                iter_sampling = 20, iter_warmup = 20, chains = 2)
#'
#' # Generate the continental and stratum indices
#' i <- generate_indices(model_output = m)
#'
#' # Generate only country indices
#' i_nat <- generate_indices(model_output = m, regions = "country")
#'
#' # Use a custom region specification (dummy example)
#' library(dplyr)
#' ri <- bbs_strata[["bbs_cws"]] %>%
#'   mutate(my_region = if_else(prov_state %in% "ON", "Ontario", "Rest"))
#' i_custom <- generate_indices(model_output = m,
#'                              regions = c("country", "prov_state", "my_region"),
#'                              regions_index = ri)
#'
#' @export
#'

generate_indices <- function(model_output = NULL,
                             quantiles = c(0.025, 0.05, 0.25, 0.75, 0.95, 0.975),
                             regions = c("stratum", "continent"),
                             regions_index = NULL,
                             alternate_n = "n",
                             start_year = NULL,
                             drop_exclude = FALSE,
                             max_backcast = NULL,
                             quiet = FALSE,
                             jags_mod, jags_data, alt_region_names, startyear) {

  # Deprecated/Defunct args
  if(!missing(jags_mod)) dep_stop("3.0.0", "jags_mod", "`model_output`")
  if(!missing(jags_data)) dep_stop("3.0.0", "jags_data")
  if(!missing(alt_region_names)) dep_stop("3.0.0", "alt_region_names", "`regions_index`")
  if(!missing(startyear)) {
    start_year <- startyear
    dep_warn("3.0.0", "startyear", "`start_year`")
  }

  # Checks
  check_data(model_output)

  # Get data
  stratify_by <- model_output$meta_data$stratify_by
  stratify_type <- model_output$meta_data$stratify_type
  raw_data <- model_output$raw_data
  meta_strata <- model_output$meta_strata

  check_regions(regions, stratify_by, stratify_type, regions_index)
  check_numeric(quantiles)
  check_numeric(start_year, max_backcast, allow_null = TRUE)
  check_logical(drop_exclude, quiet)

  # Start years
  if(!is.null(start_year)){
    inity <- min(raw_data$year)-1

    if(inity > start_year){
      warning(
        "Value of ", start_year, " for `start_year` is earlier than the ",
        "earliest year of the data, using ",
        start_year <- min(raw_data$year),
        " instead", call. = FALSE)
    }

  } else{
    start_year <- min(raw_data$year)
  }
  end_year <- max(raw_data$year)

  raw_data <- raw_data %>%
    # Set start year
    dplyr::group_by(.data[["strata"]]) %>%
    dplyr::mutate(first_year = min(.data$year[.data$count > 0], na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    # Trim year range
    dplyr::filter(.data$year >= .env$start_year)

  # After trimming data
  n_years <- max(raw_data$year_num) - min(raw_data$year_num) + 1

  # Backcast
  if(is.null(max_backcast)) max_backcast <- n_years

  # Posterior draws
  n <- samples_to_array(model_output, alternate_n,
                        years_to_keep = start_year:end_year)

  # Meta strata data
  meta_strata <- raw_data %>%
    dplyr::group_by(.data$strata) %>%
    dplyr::summarize(n_routes_total = dplyr::n_distinct(.data$route),
                     non_zero_weight = unique(.data$non_zero_weight)) %>%
    dplyr::left_join(meta_strata, by = "strata") %>%
    dplyr::mutate(stratum = .data$strata_name,
                  continent = "continent")

  # Adding extra regions
  if(!is.null(regions_index)) {

    # Check if strata_names don't match
    if(!all(meta_strata$strata_name %in% regions_index$strata_name)){
      stop("'strata_name's in the `regions_index` don't match 'strata_name's ",
           "in the data. ",
           "See `model_output$meta_strata` for the strata to match",
           call. = FALSE)
    }

    # Keep only relevant regions
    r <- regions[!regions %in% c("continent", "stratum")]
    regions_index <- regions_index %>%
      dplyr::select("strata_name", dplyr::all_of(r)) %>%
      dplyr::arrange(.data$strata_name) %>%
      dplyr::distinct() %>%
      dplyr::mutate(strata_name = as.character(strata_name))

    # Add new regional definitions to existing meta_strata
    meta_strata <- meta_strata %>%
      dplyr::select(-dplyr::any_of(r)) %>% # Remove any existing regions
      dplyr::left_join(regions_index, by = "strata_name") # Join in new
  }

  # Calculate strata/year-level observation statistics
  obs_strata <- raw_data %>%
    dplyr::select("strata", "year", "first_year", "count") %>%
    dplyr::group_by(.data$strata) %>%
    tidyr::complete(year = seq(.env$start_year, .env$end_year), first_year) %>%
    dplyr::arrange(.data$strata, .data$year, .data$count) %>%
    dplyr::group_by(.data$strata, .data$year, .data$first_year) %>%
    dplyr::summarize(obs_mean = mean(.data$count, na.rm = TRUE),
                     n_routes = sum(!is.na(.data$count)),
                     n_non_zero = sum(.data$count > 0, na.rm = TRUE),
                     strata_remove_flag = 0, .groups = "drop")

  indices <- dplyr::tibble()
  N_all <- list()

  for(rr in regions) { #selecting the type of composite region

    if(!quiet) message("Processing region ", rr)

    # Calculate strata-level information for sub-regions in this composite region
    meta_strata_sub <- meta_strata %>%
      # Ensure region columns are character
      dplyr::mutate("{rr}" := as.character(.data[[rr]])) %>%
      dplyr::group_by(.data[[rr]]) %>%
      dplyr::mutate(
        pz_area = .data$area_sq_km * .data$non_zero_weight,
        strata_p = .data$pz_area / sum(.data$pz_area),
        area_weight = .data$area_sq_km / sum(.data$area_sq_km),
        area_weight_non_zero = .data$area_weight * .data$non_zero_weight) %>%
      dplyr::ungroup()

    # Calculate observation statistics for this composite region
    obs_region <- obs_strata %>%
      dplyr::inner_join(meta_strata_sub, by = "strata") %>%
      dplyr::mutate(obs_mean = obs_mean * area_weight_non_zero) %>%
      dplyr::group_by(.data[[rr]], .data$strata)

    # Flag strata to remove due to max_backcast
    # - Flag first max_backcast no. years IF:
    #    - If no obs in those years, AND
    #    - first_year is AFTER the current start of the data range
    #      (i.e. flag data that has no true counts in it.)

    obs_region <- obs_region %>%
      dplyr::mutate(
        flag_remove = sum(.data$n_non_zero[seq_len(.env$max_backcast)]) < 1 &
          .data$first_year > .env$start_year,
        flag_year = dplyr::if_else(.data$flag_remove &
                                     .data$year <= .data$first_year, # should be <?
                                   .data$strata_p, 0))

    # Mark strata included/excluded
    obs_region <- obs_region %>%
      dplyr::group_by(.data[[rr]], .data$year) %>%
      dplyr::mutate(
        strata_included = paste0(.data$strata_name[!.data$flag_remove],
                                 collapse = " ; "),
        strata_excluded = paste0(.data$strata_name[.data$flag_remove],
                                 collapse = " ; "))

    # Exclude if requested
    if(drop_exclude) {
      rm <- unique(obs_region$strata_name[obs_region$flag_remove])

      obs_region <- dplyr::filter(obs_region, !.data$flag_remove)
      meta_strata_sub <- dplyr::filter(meta_strata_sub, !strata_name %in% rm)
      n_sub <- n[, unique(obs_region$strata_name), ] # Keep only good
    } else n_sub <- n

    obs_region <- obs_region %>%
      dplyr::group_by(.data$strata_included, .data$strata_excluded,
                      .add = TRUE) %>%
      dplyr::summarize(
        dplyr::across(.cols = c(.data$obs_mean, .data$n_routes,
                                .data$n_routes_total,
                                .data$n_non_zero, .data$flag_year),
                      sum, na.rm = TRUE),
        .groups = "drop")

    # Calculate sample statistics for this composite region
    samples <- meta_strata_sub %>%
      # Create back up col for use in calculations
      tidyr::nest(data = -.data[[rr]]) %>%
      dplyr::group_by(.data[[rr]]) %>%
      dplyr::summarize(N = purrr::map(.data$data, calc_weights, .env$n_sub),
                       N_names = paste0(rr, "_", .data[[rr]]),
                       Q = purrr::map(.data$N, calc_quantiles,
                                      .env$quantiles)) %>%
      dplyr::mutate(r = .env$rr)

    # Save sample stats for output
    N_all <- append(N_all, setNames(samples$N, samples$N_names))

    # Calculate data summaries for output
    indices <- obs_region %>%
      #dplyr::left_join(calc_alt_names(rr, meta_strata), by = rr) %>%
      dplyr::mutate(backcast_flag = 1 - .data$flag_year,
                    region_type = .env$rr) %>%
      # Add in quantiles
      dplyr::left_join(tidyr::unnest(samples, "Q"), by = c(rr, "year")) %>%
      # Clean up
      dplyr::rename(region = .data[[rr]]) %>%
      dplyr::select("year", "region", "region_type",
                    "strata_included", "strata_excluded",
                    "index", dplyr::contains("index_q"),
                    "obs_mean", "n_routes", "n_routes_total", "n_non_zero",
                    "backcast_flag") %>%
      dplyr::bind_rows(indices, .)
  }

  meta_strata <- dplyr::select(meta_strata,
                               "strata_name", "strata", "area_sq_km",
                               dplyr::all_of(.env$regions))

  list("indices" = indices,
       "samples" = N_all,
       "meta_data" = append(model_output$meta_data,
                            list("regions" = regions,
                                 "start_year" = start_year,
                                 "n_years" = n_years)),
       "meta_strata" = meta_strata,
       "raw_data" = model_output$raw_data # Original data before trimming
       )
}







calc_weights <- function(data, n) {

  # Weight each sampled n
  n_weight <- n[, data$strata_name, , drop = FALSE]

  # Use numbers for indexing as is slightly faster
  for (i in seq_len(dim(n_weight)[1])) {       # iter
    for (j in seq_len(dim(n_weight)[2])) {     # strata_name
      n_weight[i, j, ] <- n_weight[i, j, ] * data$area_weight[j]

    }
  }

  # Sum over strata
  apply(n_weight, c(1, 3), sum)
}

calc_quantiles <- function(N, quantiles) {
  apply(N, 2, stats::quantile, probs = c(quantiles, 0.5)) %>%
    t() %>%
    as.data.frame() %>%
    setNames(c(paste0("index_q_", quantiles), "index")) %>%
    dplyr::bind_cols(year = as.numeric(dimnames(N)$year))
}

calc_alt_names <- function(r, region_names) {
  col_region_name <- dplyr::case_when(r == "prov_state" ~ "province_state",
                                      TRUE ~ r)

  region_alt_name <- dplyr::bind_cols(
    {{r}} := region_names[[r]],
    region_alt = region_names[[col_region_name]]) %>%
    dplyr::distinct()

  if(r == "bcr") {
    region_alt_name <- dplyr::mutate(region_alt_name,
                                     region_alt = paste0("BCR_", .data$region_alt))
  }

  region_alt_name
}



#' Convert STAN samples matrix to array
#'
#' Stan is all matrix [samples, strata_x_years]. Here we convert it to an
#' array with by splitting strata and years into separate dimensions.
#'
#' Looks like the order of strata_x_years is S1Y1 S2Y1 S3Y1, etc.
#'
#' @param model_output Model output from `run_model()`
#' @param alternative_n Variable to extract draws for
#' @param years_to_keep Numeric vector. All the years (1995, 1996, etc.) to
#'   retain in the samples array
#'
#' @return Three dimensional array, samples x strata x years
#' @noRd

samples_to_array <- function(model_output, alternate_n, years_to_keep) {

  # Extract samples
  n <- model_output$model_fit$draws(variables = alternate_n,
                                    format = "draws_matrix")
  # Determine dim names
  strata_name <- unique(model_output$raw_data$strata_name)
  year <- sort(unique(model_output$raw_data$year))

  # Transform samples to array with appropriate dimnames
  n <- array(as.vector(n),
             dim = c(posterior::ndraws(n), length(strata_name), length(year)),
             dimnames = list("iter" = 1:posterior::ndraws(n),
                             "strata_name" = strata_name,
                             "year" = year))

  # Filter to years selected
  years_to_keep <- years_to_keep[years_to_keep %in% year]
  n[ , , as.character(years_to_keep)]
}
